<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LawrencePeng&#39;s Blog | 专注收集代码小精灵</title>

  
  <meta name="author" content="LawrencePeng">
  

  
  <meta name="description" content="Meow">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="LawrencePeng&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="LawrencePeng&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">LawrencePeng&#39;s Blog</a>
    </h1>
    <p class="site-description">专注收集代码小精灵</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/05/Scala和Python的线性化算法方案/"><span>Scala和Python的线性化算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/05/Scala和Python的线性化算法方案/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-05T15:31:37.332Z">
          2017-11-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Scala的特性需要解决菱形继承问题，恰好Py也需要，但是两者却使用了不一样的方案，我们来看看究竟。</p>
<ul>
<li><p>How</p>
<ul>
<li><p>Scala</p>
<ul>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">C1</span> <span class="keyword">with</span> <span class="title">C2</span> <span class="keyword">with</span> ... <span class="keyword">with</span> <span class="title">Cn</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>lin(C) = C &gt;&gt; lin(C1) &gt;&gt; lin(C2) &gt;&gt; … &gt;&gt; lin(Cn)</p>
</li>
<li><p>其中&gt;&gt;代表串联并去除重复项，右侧胜出。</p>
</li>
</ul>
</li>
<li><p>Python</p>
<ul>
<li><p>经典的C3算法。</p>
<ul>
<li><p>lin(C) = merge(C, lin(C1), lin(C2), …, lin (Cn), C1, C2, …, Cn)</p>
</li>
<li><p>merge实现为：</p>
<ul>
<li>持续的选出最好的头直到list枯竭，最好的头不可以在除了开头的list中位于最后一位。一个好的头可以在多个list中位于第一个，但不能再其他位置出现(除第一个)。</li>
<li>可以记忆化实现。</li>
</ul>
</li>
<li><p>demo</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">假定有如下的类继承体系：</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">extends</span> <span class="title">O</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">O</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">C</span> <span class="title">extends</span> <span class="title">O</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">D</span> <span class="title">extends</span> <span class="title">O</span></span></div><div class="line"><span class="class"><span class="title">class</span> <span class="title">E</span> <span class="title">extends</span> <span class="title">O</span></span></div><div class="line">class K1 extends A, B, C</div><div class="line">class K2 extends D, B, E</div><div class="line">class K3 extends D, A</div><div class="line">class Z extends K1, K2, K3</div><div class="line"></div><div class="line">那么C3运算过程如下：</div><div class="line"></div><div class="line">L(O)  := [O]                                                // the linearization of O <span class="keyword">is</span> trivially the singleton list [O], because O has no parents</div><div class="line"></div><div class="line">L(A)  := [A] + merge(L(O), [O])                             // the linearization of A <span class="keyword">is</span> A plus the merge of its parents<span class="string">' linearizations with the list of parents...</span></div><div class="line"><span class="string">       = [A] + merge([O], [O])</span></div><div class="line"><span class="string">       = [A, O]                                             // ...which simply prepends A to its single parent'</span>s linearization</div><div class="line"></div><div class="line">L(B)  := [B, O]                                             // linearizations of B, C, D <span class="keyword">and</span> E are computed similar to that of A</div><div class="line">L(C)  := [C, O]</div><div class="line">L(D)  := [D, O]</div><div class="line">L(E)  := [E, O]</div><div class="line"></div><div class="line">L(K1) := [K1] + merge(L(A), L(B), L(C), [A, B, C])          // first, find the linearizations of K1<span class="string">'s parents, L(A), L(B), and L(C), and merge them with the parent list [A, B, C]</span></div><div class="line"><span class="string">       = [K1] + merge([A, O], [B, O], [C, O], [A, B, C])    // class A is a good candidate for the first merge step, because it only appears as the head of the first and last lists</span></div><div class="line"><span class="string">       = [K1, A] + merge([O], [B, O], [C, O], [B, C])       // class O is not a good candidate for the next merge step, because it also appears in the tails of list 2 and 3, but...</span></div><div class="line"><span class="string">       = [K1, A, B] + merge([O], [O], [C, O], [C])          // ...class B qualified, and so does class C; class O still appears in the tail of list 3</span></div><div class="line"><span class="string">       = [K1, A, B, C] + merge([O], [O], [O])               // finally, class O is a valid candidate, which also exhausts all remaining lists</span></div><div class="line"><span class="string">       = [K1, A, B, C, O]</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">L(K2) := [K2] + merge(L(D), L(B), L(E), [D, B, E])</span></div><div class="line"><span class="string">       = [K2] + merge([D, O], [B, O], [E, O], [D, B, E])    // select D</span></div><div class="line"><span class="string">       = [K2, D] + merge([O], [B, O], [E, O], [B, E])       // fail O, select B</span></div><div class="line"><span class="string">       = [K2, D, B] + merge([O], [O], [E, O], [E])          // fail O, select E</span></div><div class="line"><span class="string">       = [K2, D, B, E] + merge([O], [O], [O])               // select O</span></div><div class="line"><span class="string">       = [K2, D, B, E, O]</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">L(K3) := [K3] + merge(L(D), L(A), [D, A])</span></div><div class="line"><span class="string">       = [K3] + merge([D, O], [A, O], [D, A])               // select D</span></div><div class="line"><span class="string">       = [K3, D] + merge([O], [A, O], [A])                  // fail O, select A</span></div><div class="line"><span class="string">       = [K3, D, A] + merge([O], [O])                       // select O</span></div><div class="line"><span class="string">       = [K3, D, A, O]</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">L(Z)  := [Z] + merge(L(K1), L(K2), L(K3), [K1, K2, K3])</span></div><div class="line"><span class="string">       = [Z] + merge([K1, A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K1, K2, K3])    // select K1</span></div><div class="line"><span class="string">       = [Z, K1] + merge([A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K2, K3])        // fail A, select K2</span></div><div class="line"><span class="string">       = [Z, K1, K2] + merge([A, B, C, O], [D, B, E, O], [K3, D, A, O], [K3])            // fail A, fail D, select K3</span></div><div class="line"><span class="string">       = [Z, K1, K2, K3] + merge([A, B, C, O], [D, B, E, O], [D, A, O])                  // fail A, select D</span></div><div class="line"><span class="string">       = [Z, K1, K2, K3, D] + merge([A, B, C, O], [B, E, O], [A, O])                     // select A</span></div><div class="line"><span class="string">       = [Z, K1, K2, K3, D, A] + merge([B, C, O], [B, E, O], [O])                        // select B</span></div><div class="line"><span class="string">       = [Z, K1, K2, K3, D, A, B] + merge([C, O], [E, O], [O])                           // select C</span></div><div class="line"><span class="string">       = [Z, K1, K2, K3, D, A, B, C] + merge([O], [E, O], [O])                           // fail O, select E</span></div><div class="line"><span class="string">       = [Z, K1, K2, K3, D, A, B, C, E] + merge([O], [O], [O])                           // select O</span></div><div class="line"><span class="string">       = [Z, K1, K2, K3, D, A, B, C, E, O]                                               // done</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Algo/">Algo</a><a href="/tags/Scala/">Scala</a><a href="/tags/Python/">Python</a><a href="/tags/Linearization/">Linearization</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/05/Packrat_Parsing/"><span>DP your Parser</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/05/Packrat_Parsing/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-05T08:36:43.100Z">
          2017-11-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Packrat-Parsing"><a href="#Packrat-Parsing" class="headerlink" title="Packrat Parsing"></a>Packrat Parsing</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看Scala的Parser Generator库的实现，发现其支持记忆化的回溯解析，因为以前没有了解过这方面的知识，所以我就找到了其算法：Packrat Parsing好好研究了下。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>Packrat Parsing是实现线性时间复杂度的回溯解析算法。</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>很多递归下降时的算法有两种实现：</p>
<ol>
<li>回溯法， 理论能力更强，但是最差时间复杂度为指数级别。</li>
<li>预测分析，通过peek等偷看后面的token，能达到线性的复杂度。</li>
</ol>
<p>Packrat让回溯解析也能做到线性时间复杂度了。</p>
<h2 id="how"><a href="#how" class="headerlink" title="how"></a>how</h2><p>记忆化是动态规划算法的本质，因为CFG属于无状态的解析过程，所以完全可以使用记忆化的策略来进行保存中间的使用结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dv = &#123;</div><div class="line"><span class="string">'Additive'</span>:  ExprAdditive(dv),</div><div class="line"><span class="string">'Multitive'</span>: ExprMultitive(dv),</div><div class="line"><span class="string">'Primary'</span>:   ExprPrimary(dv),</div><div class="line"><span class="string">'Number'</span>:    ExprNumber(dv),</div><div class="line"><span class="string">'Char'</span>:      next_dv,</div><div class="line"><span class="string">'str'</span>:       str,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义一个类似链表的结构，每个结构结点为类似dv的结构，每个key为当前字符串位置进行解析的非终止符，不难想到，对于一个长度为m的字符串，假定有n个非终止符，最多有O(mn)个状态，所以能够达到O(n)的时间复杂度。</p>
<p>Packrat对回溯解析本身并没有太大的改动，仅仅是增加了记忆化的查询、添加，就成功达到了O(n)。</p>
<p>2*(3 + 4)的解析结果 <img src="https://pic2.zhimg.com/50/v2-add961a136e6cea2af02f2591da2d969_hd.jpg" alt="">。</p>
<p>js解析数值表达式的demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">function dvAdditive(dv)&#123;</div><div class="line">if(!(&apos;Additive&apos; in dv))&#123;</div><div class="line">dv.Additive=ExprAdditive(dv);</div><div class="line">&#125;</div><div class="line">return dv.Additive;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function ExprAdditive(dv)&#123;</div><div class="line">try&#123;</div><div class="line">var mul=dvMultitive(dv);</div><div class="line">if(dvChar(mul.dv).value==&apos;+&apos;)&#123;</div><div class="line">var add=dvAdditive(dvChar(mul.dv).dv);</div><div class="line">return &#123;</div><div class="line">&apos;value&apos;: mul.value+add.value,</div><div class="line">&apos;dv&apos;: add.dv,</div><div class="line">&#125;;</div><div class="line">&#125; else &#123;</div><div class="line">throw &#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125; catch(e) &#123;</div><div class="line">return dvMultitive(dv);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function dvMultitive(dv)&#123;</div><div class="line">if(!(&apos;Multitive&apos; in dv))&#123;</div><div class="line">dv.Multitive=ExprMultitive(dv);</div><div class="line">&#125;</div><div class="line">return dv.Multitive;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function ExprMultitive(dv)&#123;</div><div class="line">try&#123;</div><div class="line">var primary=dvPrimary(dv);</div><div class="line">if(dvChar(primary.dv).value==&apos;*&apos;)&#123;</div><div class="line">var mul=dvMultitive(dvChar(primary.dv).dv);</div><div class="line">return &#123;</div><div class="line">&apos;value&apos;: primary.value*mul.value,</div><div class="line">&apos;dv&apos;: mul.dv,</div><div class="line">&#125;;</div><div class="line">&#125; else &#123;</div><div class="line">throw &#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125; catch(e) &#123;</div><div class="line">return dvPrimary(dv);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function dvPrimary(dv)&#123;</div><div class="line">if(!(&apos;Primary&apos; in dv))&#123;</div><div class="line">dv.Primary=ExprPrimary(dv);</div><div class="line">&#125;</div><div class="line">return dv.Primary;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function ExprPrimary(dv)&#123;</div><div class="line">try&#123;</div><div class="line">if(dvChar(dv).value==&apos;(&apos;)&#123;</div><div class="line">var add=dvAdditive(dvChar(dv).dv);</div><div class="line">if(dvChar(add.dv).value==&apos;)&apos;)</div><div class="line">&#123;</div><div class="line">return &#123;</div><div class="line">&apos;value&apos;: add.value,</div><div class="line">&apos;dv&apos;: dvChar(add.dv).dv,</div><div class="line">&#125;;</div><div class="line">&#125; else &#123;</div><div class="line">throw &#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">throw &#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125; catch(e) &#123;</div><div class="line">return dvNumber(dv);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function dvNumber(dv)&#123;</div><div class="line">if(!(&apos;Number&apos; in dv))&#123;</div><div class="line">dv.Number=ExprNumber(dv);</div><div class="line">&#125;</div><div class="line">return dv.Number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function ExprNumber(dv)&#123;</div><div class="line">var value=0;</div><div class="line">while(!isNaN(dvChar(dv).value))&#123;</div><div class="line">value=value*10+parseInt(dvChar(dv).value);</div><div class="line">dv=dvChar(dv).dv;</div><div class="line">&#125;</div><div class="line">return &#123;</div><div class="line">&apos;value&apos;: value,</div><div class="line">&apos;dv&apos;: dv,</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function dvChar(dv)&#123;</div><div class="line">if(!(&apos;Char&apos; in dv))&#123;</div><div class="line">dv.Char=&#123;</div><div class="line">&apos;value&apos;: dv.str[0],</div><div class="line">&apos;dv&apos;: &#123;</div><div class="line">&apos;str&apos;: dv.str.slice(1),</div><div class="line">&#125;,</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return dv.Char;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Expr(str)&#123;</div><div class="line">return ExprAdditive(&#123;</div><div class="line">&apos;str&apos;: str,</div><div class="line">&#125;).value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Ref: <a href="https://zhuanlan.zhihu.com/p/25260077" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25260077</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Algo/">Algo</a><a href="/tags/Scala/">Scala</a><a href="/tags/DP/">DP</a><a href="/tags/Parser/">Parser</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/30/Dropbox-Web-Server优化笔记/"><span>Dropbox Web Server优化笔记</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/30/Dropbox-Web-Server优化笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-29T17:11:13.418Z">
          2017-10-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://www.evernote.com/l/Ako9JcTFGjRKuawWE0fGG_AR7tata12cZ8M" target="_blank" rel="external">https://www.evernote.com/l/Ako9JcTFGjRKuawWE0fGG_AR7tata12cZ8M</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Dropbox/">Dropbox</a><a href="/tags/Infra/">Infra</a><a href="/tags/Optimization/">Optimization</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/28/谢天谢地，HPKP倒了。/"><span>谢天谢地，HPKP倒了</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/28/谢天谢地，HPKP倒了。/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-28T06:54:30.900Z">
          2017-10-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ul>
<li>What<ul>
<li>HPKP是一种Trust on First Use的减少CA被攻击的印象的技术。</li>
</ul>
</li>
<li>How<ul>
<li>第一次用户访问的时候通过meta元素或消息头告诉client在未来某段时间只信任xxx公钥，如果后面访问server没有这个公钥，至少标识给用户看看。</li>
</ul>
</li>
<li>Why<ul>
<li>因为CA太多了，如果一家gg了，client得到的证书都不一定有用。</li>
<li>HPKP这种方式可以保证只相信某些公钥。</li>
</ul>
</li>
<li>What<ul>
<li>最近Chrome宣布18年要<a href="https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/he9tr7p3rZ8/eNMwKPmUBAAJ" target="_blank" rel="external">完全移除HPKP</a>。除了HPKP本身的问题外，大家可以想想这种机制的问题何在？</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Security/">Security</a><a href="/tags/HPKP/">HPKP</a><a href="/tags/HTTP/">HTTP</a><a href="/tags/Web/">Web</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/27/给CS新生看的老饼的心声/"><span>给CS新生看的老饼的心声</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/27/给CS新生看的老饼的心声/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-26T18:50:11.000Z">
          2017-09-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ul>
<li><p>动机</p>
<ul>
<li><p>本来某人说要给新生演讲，不知道讲什么，我说我也想讲，她送上了👎的眼神，估计是因为</p>
<p><code>作为一只老饼，如果倚老卖老谈所谓的经验，那就很恶心了。</code></p>
</li>
<li><p>那我就只讲点我觉得比较正的三观吧。毕竟新生们应该能走出更好的路，非得把自己标榜的多厉害树立『权威』其实挺无趣的。</p>
</li>
</ul>
</li>
<li><p>正文</p>
<ul>
<li>目的<ul>
<li>我经常问自己的一个问题是：我为什么想要学计算机？我以前总是觉得这个问题挺虚的，后面发现这才是对我来说最根本的一个问题，我也找了很久，曾经我给出了几个答案：<ul>
<li>做出伟大的项目</li>
<li>money</li>
<li>名声</li>
<li>荷尔蒙</li>
<li>进入好公司工作</li>
</ul>
</li>
<li>最后我的答案是：<ul>
<li>追求自己的极限。</li>
<li>用我最喜欢的计算机书籍《SICP》的前言来说就是：<ul>
<li><code>我认为，在计算机科学中保持计算中的趣味性是特别重要的事情。这一学科在起步时饱含趣味性。当然，那些付钱的客户们时常觉得受了骗。一段时间之后，我们开始严肃地看待他们的抱怨。我们开始感觉到，自己真的像是要负起成功地、无差错地、完美地使用这些机器的责任。我不认为我们可以做到这些。我认为我们的责任是去拓展这一领域，将其发展到新的方向，并在自己的家中保持趣味性。我希望计算机科学的领域绝不要丧失其趣味意识。最重要的是，我希望我们不要成为**传道士**，不要认为你是兜售圣经的人，世界上这种人太多了。你所知道的所有关于计算的东西，其他人也都能学到。绝不要认为成功计算的钥匙就掌握在你手里。你所掌握的，也是我认为并希望的，也就是智慧：**那种看到这一机器比你第一次站在它面前时能够做的更多的能力，这样你才能将它向前推进。**</code></li>
<li>我觉得它差不多就是求知若虚，虚幻若谷的琐碎版了，不过可能对我更加有用些。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>基础知识<ul>
<li>基础知识的重要意义是很显而易见的，缺少基础的时候，最后很难发现一些联系、洞见。之前有人和我说XXX语言没有指针，先不说讨论语言本身的意义，最后那个其实也是Implicit的。。。这就很尴尬了。</li>
<li>基础和底层是两回事，计算机科学本身就是错误的名字，下次说的时候记着默念：『计算科学』。</li>
<li>很多人去看源码、标准等等，说自己看过XXX了，所以我理解了原理，我觉得：<ul>
<li>理解原理的判定标准是你能否构建一个新的东西呢？</li>
</ul>
</li>
<li>自上而下和自下而上的关系聊了很多次了，我给出对于我来说比较满意的答案：<ul>
<li>自上而下可以破除神秘感，但弱化构造能力。</li>
<li>自下而上可以真正理解原理，但时间成本更高。</li>
<li>所以还是万能的狗皮膏药：看情况吧。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>语言<ul>
<li>作为一个语言不可知论者，讲这个其实本身也是有很强的政治意味的，因为不关心语言本身也是一种对语言的态度。</li>
<li>语言是一种选择，但不是目的，关心钉子「目标」而不要关心锤子「本身」。</li>
<li>如果XXX都是图灵完全的，那就把时间花在讨论它抽象了哪些东西吧。</li>
</ul>
</li>
<li>资源<ul>
<li>优秀的东西总是稀少的。优秀的东西总是稀少的。<ul>
<li>每天我的Reeder都有上千篇前端文章入库，实际上多是入门级的文章。</li>
<li>永远不要马上相信自己找到的是好东西。</li>
</ul>
</li>
<li>教育、努力最后构造的其实是一个品位，你才是那个最重要的内容过滤器。</li>
<li>信息爆炸不是放弃收集信息的借口。</li>
</ul>
</li>
<li>广度和深度<ul>
<li>凡事把问题二元化的人都是文革的遗风。</li>
<li>理解相互促进、共生的意义。</li>
</ul>
</li>
<li>绩点、工作、社团、项目、研究哪个重要？<ul>
<li>有个概念叫做偏序，它们就是偏序的。</li>
<li>但凡有人摆出来绩点高/工作好…秒杀全场的论调，慎重。</li>
<li>你的目的是什么？</li>
</ul>
</li>
<li>方向问题<ul>
<li>你应该有自己的主见，在方向问题上其实只有你才是执行者。</li>
<li>如果你觉得XXX方向一定比YYY方向好，请再次查询『偏序』。</li>
</ul>
</li>
<li>刻板印象<ul>
<li>程序员的笑话这类的东西，最终都是很低俗的。</li>
<li>女生就学不好计算机是刻板印象。</li>
<li>程序员猝死多是刻板印象。</li>
<li>程序员木讷是有恶意的刻板印象。</li>
<li>……</li>
</ul>
</li>
<li>生产者和消费者<ul>
<li>热衷于消费没有错，但生产者不是更好玩点么？</li>
<li>消费者是猪。这句话不是我说的。。。</li>
</ul>
</li>
</ul>
<ul>
<li>给迷茫新手的CS干货书单<ul>
<li>《SICP》<ul>
<li>能让你重新”正确”思考计算机科学、语言、抽象、函数式…诸多概念。</li>
<li>它就是CS领域的『The Book』。</li>
</ul>
</li>
<li>《CSAPP》<ul>
<li>看似很厚，其实是最快的捷径。</li>
<li>一本书顶5门课。</li>
</ul>
</li>
<li>《线性代数就应该这样学》<ul>
<li>书名已经解释了一切。</li>
</ul>
</li>
<li>《黑客与画家》<ul>
<li>黑客的黑不是说技术，而是思维。</li>
</ul>
</li>
<li>《暗时间》<ul>
<li>榜样的力量是无穷的。</li>
</ul>
</li>
<li>《人月神话》<ul>
<li>预言者的力量是无穷的。</li>
<li>洞见太少了，所以才宝贵。</li>
</ul>
</li>
<li>《计算的本质》<ul>
<li>其实是讲计算理论的书。</li>
</ul>
</li>
<li>《程序员修炼之道》<ul>
<li>还是因为洞见太少了，所以才宝贵。</li>
</ul>
</li>
<li>《元素模式》<ul>
<li>《设计模式》解毒剂。</li>
<li>KISS才是王道好吧。</li>
</ul>
</li>
<li>《风格的要素》<ul>
<li>说英语的话，还是这本最解毒。</li>
</ul>
</li>
<li>《编程原本》<ul>
<li>真的要理解C++ STL，不如看作者怎么说的。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/23/Odd-Sketch/"><span>Odd Sketch</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/23/Odd-Sketch/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-23T06:59:49.000Z">
          2017-09-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>之前介绍了过一个Sketch了，现在再介绍一个吧。今天介绍的这个是Odd Sketch。它是用来快速估计集合相似度Jaccard similarity的。</p>
<ul>
<li>实现<ul>
<li>新建一个n bits的sketch S，置0。</li>
<li>选一个随机哈希函数</li>
<li>对集合每个元素<ul>
<li>Sh(x) = Sh(x) xor 1</li>
</ul>
</li>
<li>返回S</li>
</ul>
</li>
</ul>
<ul>
<li>性质<ul>
<li>Odd(S1) xor Odd(S2) = Odd(S1 diff S2)</li>
</ul>
</li>
</ul>
<ul>
<li>估计<ul>
<li>估计集合大小<ul>
<li>让m和n分别代表集合S和Odd(S)的比特大小。因为哈希函数全随机，我们可以认为构造Odd(S)的过程是m球丢n桶实验。Odd(S)i最后为第i个桶的球数的奇偶性。这样想的话我们有两种方式来构造集合大小。<ol>
<li>每一次丢球，对于任意一个桶来说都有1/n的几率转换球数奇偶性的状态，所以就当成简单的2-state Markov chain就好了。设pi为丢完i个球后任意一个给定的桶有奇数个球的概率。我们很容易知道：pi = （1 - (1 - 2/n)^i) / 2，这是标准的马式链的题目了。</li>
<li>不难推出m个球丢出去后所有奇数桶的数量的期望E[X] = n (1 - ((1 - 2 / n) ^ m) / 2)</li>
<li>现在假设有了z为奇数桶数，不难倒估m为ln(1 - 2z/ n) / ln(1 - 2/n)</li>
</ol>
</li>
<li>当m球丢进了n桶，对于一个桶来说，可以认为其为一个均值u = m / n的泊松过程，<ul>
<li>令p为有一个桶奇数个球的概率，则p =  sum all i odd (e^(-u) * (u^i)) / i! = (1 - e^(-2u))/2。</li>
<li>令Y为整个过程结束后m个桶中奇数球数桶的期望,则有: E[Y] = np = n(1 - (e^(-2m / n)) / 2)</li>
<li>所以通过奇数桶数z可倒估m为-(n/2) * ln(1 - 2z/n)。</li>
<li>当n很大时，ln(1 - 2/n)约等于-2/n，这样和第一个等式就差不多了。</li>
</ul>
</li>
</ul>
</li>
<li>估计Jaccard Similarity<ul>
<li>E[|S1 diff S2|] = 2k(1 - J),其中k是独立置换的数量。J是我们要估计的Jaccard Similarity。</li>
<li>我们上面的Odd Sketch的过程可以帮助我们找到|S1 diff S2|的一个估计为- (n / 2) * ln(1 - 2 |Odd(S1) diff Pdd(S2)|/n)，其中|Odd(S1) diff Odd(S2)|就是我们构造的的2个Odd Sketch不同的位数。现在根据E[|S1 diff S2|] = 2k(1 - J)，我们可以逆估<ul>
<li>J = 1 - |S1 Diff S2|/2k = 1 + (n/4k) * ln(1 - 2|Odd(S1) diff Odd(S2)| / n)    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>后面的其他的估计我们就不讲了，说下结论，它在高Jaccard Similarity的情况下，比minhash的表现更好哦。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Algo/">Algo</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/10/CRDT/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/10/CRDT/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-10T12:40:21.000Z">
          2017-08-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <hr>
<h2 id="CRDT-A-Way-to-implement-eventual-consistency"><a href="#CRDT-A-Way-to-implement-eventual-consistency" class="headerlink" title="CRDT:A Way to implement eventual consistency"></a>CRDT:A Way to implement eventual consistency</h2><ul>
<li>BlahBlahBlah<ul>
<li>很多人都应该听过<a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="external">CAP Theorem</a>，如果你没有，理解这篇文章可能有点费劲，推荐你看看。</li>
<li>如果你选择了AP，那么你最终可能会面临的问题就是你要不要达到最终一致性了。</li>
<li>如果你选择了否，那么这篇文章可能不对应你的场景了。</li>
<li>如果你选择了是，那么如何实现最终一致性呢？这就导出了CRDT。</li>
</ul>
</li>
</ul>
<ul>
<li>原理<ul>
<li>有两类的CRDT。</li>
<li>CmRDT<ul>
<li>结点和结点传输的是符合交换律的操作，如果不符合幂等性，那么你可能需要依赖你的通讯机制能够达到extract one message delivered的要求。</li>
<li>Pure CmRDT可以减少所需要传输的metadata的大小。</li>
</ul>
</li>
<li>CvRDT<ul>
<li>结点和结点传输的是状态，存在一个算子merge: (SA, SB) =&gt; SC,收到传输的状态就和自己存储的状态merge，这个算子必须满足交换律、结合律和幂等律，所以如果用抽象代数的角度形容地话，其使整个状态系统形成了一个<a href="https://en.wikipedia.org/wiki/Semilattice" target="_blank" rel="external">半格</a>。所以最终只要能接受到其他所有节点的新状态，那么永远能保证系统最终会收敛。这样也去除了对于CmRDT的底层通讯机制依赖，但是因为传递的是状态，所以最后传输可能有点大。虽然还有优化的可能性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>例子我就不举了，大家G嫂一下就好了。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/04/为什么你应该对生活充满希望？/"><span>为什么你应该对生活充满希望？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/04/为什么你应该对生活充满希望？/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-04T08:01:09.000Z">
          2017-08-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ul>
<li>最近刚好到了秋招的时间段，相信各位老饼们肯定都在摩拳擦掌地准备ing，或者成功ed。不管怎样，都要努力哦。</li>
</ul>
<ul>
<li>Birthday Paradox<ul>
<li>为什么你应该对生活充满希望？或者说为什么你应该坚持呢？</li>
<li>我相信生日悖论会把很多东西解释地很清楚。</li>
<li>n个人随机分发给n^2个坑（或者生日），有50%的几率会有冲突（两人站一个坑。）</li>
<li>攻击方式：生日攻击。<ul>
<li>既然那么高那就搞事情嘛，所以crypto hash的话，大小要设好哦。</li>
</ul>
</li>
<li>所以你应该勇敢暴破（坚持）哦。</li>
<li>对了，最近CACM有个讲暴破的<a href="https://cacm.acm.org/magazines/2017/8/219606-the-science-of-brute-force/fulltext" target="_blank" rel="external">文章</a>挺好玩的。</li>
</ul>
</li>
</ul>
<ul>
<li>祝大家秋招都有好job哦。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Cryptology/">Cryptology</a><a href="/tags/Math/">Math</a><a href="/tags/Probability/">Probability</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/31/方差与协方差的关系的可视化表示/"><span>方差与协方差的关系的可视化表示</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/31/方差与协方差的关系的可视化表示/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-31T01:10:39.000Z">
          2017-07-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当年学协方差的时候，感觉总是很不直观。所以我选择了可视化的方式来了解它。直到我看到了这张图，我才更加相信一图胜千言的意义。</p>
<p><img src="https://assessingpsyche.files.wordpress.com/2012/09/visualizingcovariance.png" alt=""></p>
<p>现在很多性质都是很容易得到的了，随便举几个：</p>
<ul>
<li>Cov(A, A) is Var(A)</li>
<li>Cov(A, B) is Cov(B, A)</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Probability-Theory/">Probability Theory</a><a href="/tags/Visualization/">Visualization</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/30/SuccinctStore深度解析-—-CSA实现/"><span>SuccinctStore深度解析 — CSA实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/30/SuccinctStore深度解析-—-CSA实现/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-30T03:40:39.000Z">
          2017-07-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ul>
<li>前提<ul>
<li>SuccinctStore依靠Compressed Suffix Array这一数据结构进行构建，实际上这也是因为CSA在空间使用上会优于CST。不过，如果没有从理论上明白它的一些时空复杂度，我相信是没人刚用的。要是突然我能构造出一个异常的输入样本，导致糟糕的怎么办？所以我们先来看下它的时间空间复杂度吧。</li>
<li>时间复杂度：O(n)，实际上有很多好的CSA的构建算法都能达到这个上界，做竞赛的同学们可能会比较熟悉DC3算法。</li>
<li>空间复杂度：O(n)，这个也没什么悬念的？真的吗？对于CSA来说，我们需要更加紧的上界，这里就要提出k-th order empirical entropy了。<ul>
<li>zero-th order empirical entropy<ul>
<li>要理解k-th order empirical entropy，首先要理解zero-th order empirical entropy。</li>
<li>zero-th order empirical entropy是单独压缩每个单词最后能压缩的大小，可以看出，它并没有利用到上下文信息。</li>
</ul>
</li>
<li>k-th order empirical entropy，高级的压缩器能利用这一上下文并根据这一上下文选出不同的codeword，k是这个上下文的大小，k越大，当然压缩率会越高，但是这个上下文表示所需要的空间也会相应变大，一般我们需要有个empirical的选值。公式大家可以g娘一下。</li>
<li>CSA的空间复杂度为O(nHk(T)) + o(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>实现<ul>
<li>目标<ul>
<li>f = compress(file)</li>
<li>append(f, buffer)</li>
<li>buffer = extract(f, offset, len)</li>
<li>cnt = count(f, str)</li>
<li>offsets = search(f, str)</li>
<li>offsets = rangesearch(f, str1, str2)</li>
<li>ranges = wildcardsearch(f, prefix, suffix, dist)</li>
<li>offsets = regex(f, pattern)</li>
</ul>
</li>
<li>Flat Text To Semi-structured Data<ul>
<li>一些简单的拓展就能让我们实现更加复杂的数据模型。</li>
<li><img src="http://imglf1.nosdn.127.net/img/R0xHYjBEcUE1MmlpVmQ4TkQ2bm02KzdlcXFpWnFRV1JZaTViakw5ZWZVaTVkT29sbGpoc0tnPT0.png?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></li>
</ul>
</li>
<li>Suffix Array 运用<ul>
<li>我们维护两个数组AoS2Input和Input2AoS，不难看出这两个互为反函数。</li>
<li>当我们要search某Pattern p的时候，binary search p所在的两个端点，返回成区间形式即可。</li>
<li>当我们要extract的时候，利用Input2AoS，直接是一个O(1)的操作。</li>
</ul>
</li>
<li>压压压<ul>
<li>原先的实现会需要维护O(nlog + n^2)的空间。所以考虑引入新的数组NextCharIdx，NextCharIdx(idx) -&gt; NextIndexInAoS。</li>
<li>这样我们只需要mark每个单词出现的首个index即刻，后面需要定位的时候follow NextCharIdx，通过binary search到对应的字符Offset即可。</li>
<li>对于AoS2Input和Input2AoS两个输出，我们采用取样的方法减小其大小。默认选择这两个数组的大小为原数组的1/32。</li>
<li>因为NextCharIdx本身是单调递增的，所以我们可以选择一些编码方式做DeltaCompression， 这里我使用的是Elias Gamma Code。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Database/">Database</a><a href="/tags/Succinct-Data-Structure/">Succinct Data Structure</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 LawrencePeng
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>